// Generated by CoffeeScript 1.3.3

/*
 Settings
*/


(function() {
  var EOL, FILE_ENCODING, build_dir, changeDir, checkConfiguration, cleanUpDir, cleanUpDirWorker, coffee, coffeeSources, colors, compileAssets, compileCoffee, compileCoffeeDir, compileLess, compileLessDir, compiledAssets, configuration, copyLavaFiles, copyPluginFiles, copyToTestServer, createTmpDir, downQueue, exists, fs, fse, getAbsDir, getCoffeeFiles, lavaVars, lavaVarsWorker, less, logging, namespaceClasses, namespaceClassesWorker, path, program, queue, upQueue, wrench, yaml, _allowed_extensions, _other_extensions,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  FILE_ENCODING = 'utf-8';

  EOL = '\n';

  /*
   Module dependencies
  */


  coffee = require('coffee-script');

  colors = require('colors');

  program = require('commander');

  fs = require('fs');

  fse = require('fs-extra');

  yaml = require('js-yaml');

  less = require('less');

  path = require('path');

  wrench = require('wrench');

  exists = fs.exists || path.exists;

  configuration = {};

  /*
   Global vars
  */


  build_dir = '/_tmp/';

  _allowed_extensions = ["css", "html", "js", "md", "php", "png", "po", "pot", "twig", "txt", "yml", "yaml"];

  _other_extensions = ["git", "gitattributes", "gitignore", "less", "coffee", "meta"];

  coffeeSources = [];

  queue = 0;

  /*
   Logging
  */


  logging = Object;

  logging.log = function(message) {
    return console.log(message);
  };

  logging.error = function(message) {
    return console.error(message.red);
  };

  logging.verbose = function(message) {
    if (program.verbose) {
      return console.info(message.yellow);
    }
  };

  logging.verboseGreen = function(message) {
    if (program.verbose) {
      return console.info(message.green);
    }
  };

  logging.verboseRed = function(message) {
    if (program.verbose) {
      return console.info(message.red);
    }
  };

  getAbsDir = function(filepath) {
    return path.join(process.cwd(), filepath);
  };

  exports.run = function(done) {
    if (done == null) {
      done = 'run';
    }
    program.version('1.0.0').option('-d, --distribute', 'Build distribution version').option('-v, --verbose', 'Prints debug stuff to screen').option('-n, --nonamespacing', 'Does not change lava_ into plugin namespace if this flag is present').parse(process.argv);
    program.parse(process.argv);
    return checkConfiguration();
  };

  checkConfiguration = function() {
    logging.verbose('Checking file structure...');
    if (!fs.existsSync(getAbsDir('/lofty.yaml'))) {
      logging.error("No lofty.yaml file found in current directory");
    }
    if (!fs.existsSync(getAbsDir('/src/'))) {
      logging.error("No /src/ directory found");
    }
    if (!fs.existsSync(getAbsDir('/libs/lava/classes/plugin.php'))) {
      logging.error("No /libs/lava/clases/plugin.php file found. Please ensure that git-submodules are initialised");
    }
    try {
      configuration = require(getAbsDir('/lofty.yaml'));
    } catch (e) {
      logging.error('Error in lofty.yaml file');
      console.log(e);
    }
    logging.verboseGreen('Lofty.yaml file loaded');
    if (program.distribute) {
      logging.verboseGreen('Distribution Build');
      build_dir = "/dist/";
    } else {
      logging.verboseGreen('Development Build');
      build_dir = '/build/';
    }
    return createTmpDir();
  };

  createTmpDir = function(called) {
    if (called == null) {
      called = 0;
    }
    called = called + 1;
    if (fs.existsSync(getAbsDir(build_dir))) {
      try {
        logging.verbose('Old temporary directory exists');
        wrench.rmdirSyncRecursive(getAbsDir(build_dir));
        logging.verbose('Old temporary directory deleted');
      } catch (e) {
        if (called < 10) {
          createTmpDir(called);
        } else {
          logging.error('Error removing old build directory - have you got a file open?');
        }
      }
    }
    try {
      fs.mkdirSync(getAbsDir(build_dir));
    } catch (e) {
      if (called < 10) {
        createTmpDir(called);
      } else {
        logging.error('Error creating new build directory');
      }
    }
    logging.verboseGreen('New temporary directory created');
    return copyLavaFiles();
  };

  copyLavaFiles = function() {
    var dest, src;
    try {
      logging.verboseGreen('Copying Lava files');
      src = getAbsDir('/libs/lava/');
      dest = getAbsDir(build_dir);
      return fse.copy(src, dest, copyPluginFiles);
    } catch (e) {
      logging.error('Error copying files to build directory');
      console.error(e);
      return process.exit();
    }
  };

  copyPluginFiles = function() {
    var dest, src;
    try {
      logging.verboseGreen('Copying Plugin files');
      src = getAbsDir('/src/');
      dest = getAbsDir(build_dir);
      return fse.copy(src, dest, changeDir);
    } catch (e) {
      logging.error('Error copying files to build directory');
      console.error(e);
      return process.exit();
    }
  };

  changeDir = function() {
    logging.verbose('Switching into build directory');
    process.chdir(getAbsDir(build_dir));
    return compileAssets();
  };

  /*
  	Walk through LESS directory compiling to css
  */


  compileAssets = function() {
    logging.verbose('Compiling assets');
    compileLess();
    return compileCoffee();
  };

  compileLess = function() {
    return compileLessDir(getAbsDir());
  };

  compileLessDir = function(dir) {
    var absFile, file, files, outfile, parser, preCompile, prefix, _i, _len, _results;
    parser = new less.Parser;
    prefix = dir + '/';
    files = fs.readdirSync(dir);
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      absFile = prefix + file;
      if (fs.statSync(absFile).isDirectory()) {
        _results.push(compileLessDir(absFile));
      } else {
        if (file.substr(-5) === '.less') {
          if (file.substr(0, 1) !== '_') {
            logging.verboseGreen("Compiling " + file);
            outfile = absFile.replace(/less/g, 'css');
            parser = new less.Parser({
              paths: [dir],
              filename: absFile
            });
            preCompile = fs.readFileSync(absFile, FILE_ENCODING);
            upQueue();
            _results.push(parser.parse(preCompile, function(err, tree) {
              var postCompile;
              if (err) {
                return console.error(err);
              }
              if (program.distribute) {
                postCompile = tree.toCSS({
                  compress: true
                });
              } else {
                postCompile = tree.toCSS();
              }
              fs.writeFileSync(outfile, postCompile, FILE_ENCODING);
              if (downQueue()) {
                return compiledAssets();
              }
            }));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  compileCoffee = function() {
    logging.verbose('Compiling coffee files');
    coffeeSources = [getAbsDir()];
    return compileCoffeeDir(getAbsDir(), true, path.normalize(getAbsDir()));
  };

  compileCoffeeDir = function(dir) {
    var absFile, code, file, files, outfile, postCompile, preCompile, _i, _len, _results;
    files = fs.readdirSync(dir);
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      absFile = dir + '/' + file;
      if (fs.statSync(absFile).isDirectory()) {
        if (file.substr(-7) === '.coffee') {
          code = getCoffeeFiles(absFile, {}, true);
          code = coffee.compile(code);
          outfile = absFile.replace(/coffee/g, 'js');
          _results.push(fs.writeFileSync(outfile, code, FILE_ENCODING));
        } else {
          _results.push(compileCoffeeDir(absFile));
        }
      } else {
        if (file.substr(-7) === '.coffee') {
          if (file.substr(0, 1) !== '_') {
            logging.verboseGreen("Compiling " + file);
            outfile = absFile.replace(/coffee/g, 'js');
            preCompile = fs.readFileSync(absFile, FILE_ENCODING);
            upQueue();
            postCompile = coffee.compile(code);
            fs.writeFileSync(outfile, postCompile, FILE_ENCODING);
            if (downQueue()) {
              _results.push(compiledAssets());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  getCoffeeFiles = function(dir, coffeeFiles, concat) {
    var absFile, file, files, i, returnCode, _i, _len;
    if (concat == null) {
      concat = false;
    }
    files = fs.readdirSync(dir);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      absFile = dir + '/' + file;
      if (fs.statSync(absFile).isDirectory()) {
        coffeeFiles = getCoffeeFiles(absFile, coffeeFiles);
      } else {
        if (file.substr(-7) === '.coffee') {
          if (file.substr(0, 4) === 'main') {
            coffeeFiles['0' + absFile] = fs.readFileSync(absFile, FILE_ENCODING);
          } else {
            coffeeFiles[absFile] = fs.readFileSync(absFile, FILE_ENCODING);
          }
        }
      }
    }
    if (concat) {
      returnCode = '';
      for (i in coffeeFiles) {
        returnCode = returnCode + "\n" + coffeeFiles[i];
      }
      return returnCode;
    } else {
      return coffeeFiles;
    }
  };

  compiledAssets = function() {
    return namespaceClasses();
  };

  namespaceClasses = function() {
    logging.verbose('Namespacing php classes');
    namespaceClassesWorker(getAbsDir());
    return lavaVars();
  };

  namespaceClassesWorker = function(dir) {
    var absFile, code, file, files, ns, _i, _len, _results;
    files = fs.readdirSync(dir);
    ns = configuration.class_namespace;
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      absFile = dir + '/' + file;
      if (fs.statSync(absFile).isDirectory()) {
        _results.push(namespaceClassesWorker(absFile));
      } else {
        if (file.substr(-4) === '.php') {
          code = fs.readFileSync(absFile, FILE_ENCODING);
          code = code.replace(/^\s*class\s+Lava(.*?)\s+extends\s+Lava(.*?)\s*{*\s*$/gm, "class " + ns + "$1 extends " + ns + "$2");
          code = code.replace(/^\s*class\s+(.*?)\s+extends\s+Lava(.*?)\s*{*\s*$/gm, "class $1 extends " + ns + "$2");
          code = code.replace(/^\s*class\s+Lava(.*?)\s+extends\s+(.*?)\s*{*\s*$/gm, "class " + ns + "$1 extends $2");
          code = code.replace("$the_plugin = new Lava( __FILE__ );", "$the_plugin = new " + ns + "( __FILE__ );");
          _results.push(fs.writeFileSync(absFile, code));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  lavaVars = function() {
    logging.verbose('Parsing lava vars');
    lavaVarsWorker(getAbsDir());
    return cleanUpDir();
  };

  lavaVarsWorker = function(dir) {
    var absFile, code, file, files, ns, pattern, variable, _i, _len, _results;
    files = fs.readdirSync(dir);
    ns = configuration.class_namespace;
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      absFile = dir + '/' + file;
      if (fs.statSync(absFile).isDirectory()) {
        _results.push(lavaVarsWorker(absFile));
      } else {
        if (file.substr(-4) === ('.php' || '.txt')) {
          code = fs.readFileSync(absFile, FILE_ENCODING);
          for (variable in configuration) {
            pattern = new RegExp("\\{\\{\\s*lava." + variable + "\\s*\\}\\}");
            code = code.replace(pattern, configuration[variable]);
          }
          _results.push(fs.writeFileSync(absFile, code));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  cleanUpDir = function() {
    logging.verbose('Cleaning up directory');
    return cleanUpDirWorker(process.cwd());
  };

  cleanUpDirWorker = function(dir) {
    if (fs.existsSync(dir)) {
      upQueue();
      return fs.readdir(dir, function(err, files) {
        var absFile, ext, file, new_dir, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          absFile = "" + dir + "/" + file;
          if (fs.existsSync(absFile)) {
            if (fs.statSync(absFile).isDirectory()) {
              cleanUpDirWorker(absFile);
            } else {
              ext = file.substr(file.lastIndexOf('.') + 1);
              if (__indexOf.call(_allowed_extensions, ext) < 0) {
                if (__indexOf.call(_other_extensions, ext) >= 0) {
                  fs.unlinkSync(absFile);
                } else {
                  logging.verboseRed("Un-handled extension '" + ext + "'");
                }
              }
            }
          }
        }
        if (fs.existsSync(dir) && fs.readdirSync(dir).length === 0) {
          fs.rmdirSync(dir);
          new_dir = path.resolve(dir, '../');
          cleanUpDirWorker(new_dir);
        }
        if (downQueue()) {
          return copyToTestServer();
        }
      });
    }
  };

  copyToTestServer = function() {
    var dest, src;
    if (configuration.test_server !== void 0) {
      logging.verbose('Copying to test server');
      src = getAbsDir();
      dest = configuration.test_server;
      return fse.copy(src, dest, function(err, other) {});
    }
  };

  upQueue = function() {
    return queue = queue + 1;
  };

  downQueue = function() {
    queue = queue - 1;
    if (queue === 0) {
      return true;
    }
  };

}).call(this);
